# task_service/app.py
from flask import Flask, request, jsonify
from flask_cors import CORS
import sqlite3
import uuid
import datetime
import os
import requests
from datetime import datetime

app = Flask(__name__)
CORS(app)  # Enable CORS for frontend communication

# Database setup
# DATABASE = 'tasks.db' replaced
DATABASE = os.environ.get('DATABASE', 'tasks.db')
USER_SERVICE_URL = os.environ.get('USER_SERVICE_URL', 'http://localhost:5001')

# Ensure data directory exists if using volume mount
def ensure_data_directory():
    db_dir = os.path.dirname(DATABASE)
    if db_dir and not os.path.exists(db_dir):
        os.makedirs(db_dir, exist_ok=True)

def get_db_connection():
    conn = sqlite3.connect(DATABASE)
    conn.row_factory = sqlite3.Row
    return conn

def init_db():
    """Initialize the database with tasks table"""
    ensure_data_directory()
    conn = get_db_connection()
    conn.execute('''
        CREATE TABLE IF NOT EXISTS tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            title TEXT NOT NULL,
            description TEXT,
            status TEXT DEFAULT 'pending',
            priority TEXT DEFAULT 'medium',
            due_date TIMESTAMP,
            created_at TIMESTAMP,
            updated_at TTIMESTAMP,
            completed_at TIMESTAMP
        )
    ''')
    
    # Create index for better query performance
    conn.execute('CREATE INDEX IF NOT EXISTS idx_user_id ON tasks(user_id)')
    conn.execute('CREATE INDEX IF NOT EXISTS idx_status ON tasks(status)')
    
    conn.commit()
    conn.close()

def verify_user_exists(user_id):
    """Verify that a user exists by calling the User Service"""
    try:
        response = requests.get(f"{USER_SERVICE_URL}/api/users/profile/{user_id}", timeout=5)
        return response.status_code == 200
    except requests.exceptions.RequestException:
        return False

def validate_task_data(data, required_fields=['title', 'user_id']):
    """Validate task data"""
    errors = []
    
    # Check required fields
    for field in required_fields:
        if field not in data or not data[field]:
            errors.append(f"{field} is required")
    
    # Validate specific fields
    if 'title' in data and len(data.get('title', '').strip()) < 1:
        errors.append("Title cannot be empty")
    
    if 'status' in data and data['status'] not in ['pending', 'in_progress', 'completed', 'cancelled']:
        errors.append("Status must be one of: pending, in_progress, completed, cancelled")
    
    if 'priority' in data and data['priority'] not in ['low', 'medium', 'high', 'urgent']:
        errors.append("Priority must be one of: low, medium, high, urgent")
    
    # Validate due_date format if provided
    if 'due_date' in data and data['due_date']:
        try:
            datetime.datetime.fromisoformat(data['due_date'])
        except ValueError:
            errors.append("Due date must be in ISO format (YYYY-MM-DDTHH:MM:SS)")
    
    return errors

# Routes
#@app.route('/health', methods=['GET'])
# def health_check():
#     """Health check endpoint"""
#     # Check database connection
    # try:
    #     conn = get_db_connection()
    #     conn.execute('SELECT 1').fetchone()
    #     conn.close()
    #     db_status = 'healthy'
    # except Exception:
    #     db_status = 'unhealthy'
    
    # # Check User Service connection
    # try:
    #     response = requests.get(f"{USER_SERVICE_URL}/health", timeout=3)
    #     user_service_status = 'healthy' if response.status_code == 200 else 'unhealthy'
    # except requests.exceptions.RequestException:
    #     user_service_status = 'unhealthy'
    
    # return jsonify({
    #     'status': 'healthy' if db_status == 'healthy' and user_service_status == 'healthy' else 'degraded',
    #     'service': 'task-service',
    #     'timestamp': datetime.datetime.now().isoformat(),
    #     'dependencies': {
    #         'database': db_status,
    #         'user_service': user_service_status
    #     }
    # })
@app.route('/health', methods=['GET'])
def health_check():
    """
    Health check endpoint for Kubernetes probes.
    Checks database and user service connectivity.
    """
    try:
        # Test database connection
        conn = get_db_connection()
        conn.execute('SELECT 1')
        conn.close()
        
        # Test user service connection
        user_service_url = os.getenv('USER_SERVICE_URL', 'http://localhost:5001')
        try:
            response = requests.get(f'{user_service_url}/health', timeout=2)
            user_service_healthy = response.status_code == 200
        except:
            user_service_healthy = False
        
        if user_service_healthy:
            return jsonify({
                'status': 'healthy',
                'service': 'task-service',
                'dependencies': {
                    'user-service': 'healthy'
                },
                'timestamp': datetime.now().isoformat()
            }), 200
        else:
            return jsonify({
                'status': 'degraded',
                'service': 'task-service',
                'dependencies': {
                    'user-service': 'unhealthy'
                },
                'timestamp': datetime.now().isoformat()
            }), 200  # Still return 200 but indicate degraded state
            
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'service': 'task-service',
            'error': str(e),
            'timestamp': datetime.now().isoformat()
        }), 503  # 503 = Service Unavailable    

@app.route('/api/tasks', methods=['GET'])
def get_tasks():
    """Get tasks for a user"""
    user_id = request.args.get('user_id')
    status = request.args.get('status')
    priority = request.args.get('priority')
    
    if not user_id:
        return jsonify({'error': 'user_id parameter is required'}), 400
    
    try:
        conn = get_db_connection()
        
        # Build query with optional filters
        query = 'SELECT * FROM tasks WHERE user_id = ?'
        params = [user_id]
        
        if status:
            query += ' AND status = ?'
            params.append(status)
        
        if priority:
            query += ' AND priority = ?'
            params.append(priority)
        
        query += ' ORDER BY created_at DESC'
        
        tasks = conn.execute(query, params).fetchall()
        conn.close()
        
        task_list = []
        for task in tasks:
            task_list.append({
                'id': task['id'],
                'user_id': task['user_id'],
                'title': task['title'],
                'description': task['description'],
                'status': task['status'],
                'priority': task['priority'],
                'due_date': task['due_date'],
                'created_at': task['created_at'],
                'updated_at': task['updated_at'],
                'completed_at': task['completed_at']
            })
        
        return jsonify({
            'tasks': task_list,
            'total': len(task_list)
        }), 200
        
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/api/tasks', methods=['POST'])
def create_task():
    """Create a new task"""
    try:
        data = request.get_json()
        
        # Validate input
        errors = validate_task_data(data)
        if errors:
            return jsonify({'errors': errors}), 400
        
        user_id = data['user_id']
        
        # Verify user exists
        if not verify_user_exists(user_id):
            return jsonify({'error': 'User not found'}), 404
        
        # Create task
        task_id = str(uuid.uuid4())
        now = datetime.datetime.now().isoformat()
        
        conn = get_db_connection()
        conn.execute('''
            INSERT INTO tasks (id, user_id, title, description, status, priority, due_date, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            task_id,
            user_id,
            data['title'].strip(),
            data.get('description', '').strip(),
            data.get('status', 'pending'),
            data.get('priority', 'medium'),
            data.get('due_date'),
            now,
            now
        ))
        conn.commit()
        conn.close()
        
        return jsonify({
            'message': 'Task created successfully',
            'task': {
                'id': task_id,
                'user_id': user_id,
                'title': data['title'].strip(),
                'description': data.get('description', '').strip(),
                'status': data.get('status', 'pending'),
                'priority': data.get('priority', 'medium'),
                'due_date': data.get('due_date'),
                'created_at': now,
                'updated_at': now
            }
        }), 201
        
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/api/tasks/<task_id>', methods=['GET'])
def get_task(task_id):
    """Get a specific task by ID"""
    try:
        conn = get_db_connection()
        task = conn.execute('SELECT * FROM tasks WHERE id = ?', (task_id,)).fetchone()
        conn.close()
        
        if not task:
            return jsonify({'error': 'Task not found'}), 404
        
        return jsonify({
            'task': {
                'id': task['id'],
                'user_id': task['user_id'],
                'title': task['title'],
                'description': task['description'],
                'status': task['status'],
                'priority': task['priority'],
                'due_date': task['due_date'],
                'created_at': task['created_at'],
                'updated_at': task['updated_at'],
                'completed_at': task['completed_at']
            }
        }), 200
        
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/api/tasks/<task_id>', methods=['PUT'])
def update_task(task_id):
    """Update a task"""
    try:
        data = request.get_json()
        
        # Validate input (don't require all fields for updates)
        errors = validate_task_data(data, required_fields=[])
        if errors:
            return jsonify({'errors': errors}), 400
        
        conn = get_db_connection()
        
        # Check if task exists
        existing_task = conn.execute('SELECT * FROM tasks WHERE id = ?', (task_id,)).fetchone()
        if not existing_task:
            conn.close()
            return jsonify({'error': 'Task not found'}), 404
        
        # Build update query dynamically
        update_fields = []
        params = []
        
        allowed_fields = ['title', 'description', 'status', 'priority', 'due_date']
        for field in allowed_fields:
            if field in data:
                update_fields.append(f"{field} = ?")
                params.append(data[field].strip() if isinstance(data[field], str) else data[field])
        
        if not update_fields:
            conn.close()
            return jsonify({'error': 'No valid fields to update'}), 400
        
        # Always update the updated_at timestamp
        update_fields.append("updated_at = ?")
        params.append(datetime.datetime.now().isoformat())
        
        # Handle completion timestamp
        if 'status' in data and data['status'] == 'completed' and not existing_task['completed_at']:
            update_fields.append("completed_at = ?")
            params.append(datetime.datetime.now().isoformat())
        elif 'status' in data and data['status'] != 'completed':
            update_fields.append("completed_at = ?")
            params.append(None)
        
        params.append(task_id)
        
        query = f"UPDATE tasks SET {', '.join(update_fields)} WHERE id = ?"
        conn.execute(query, params)
        conn.commit()
        
        # Get updated task
        updated_task = conn.execute('SELECT * FROM tasks WHERE id = ?', (task_id,)).fetchone()
        conn.close()
        
        return jsonify({
            'message': 'Task updated successfully',
            'task': {
                'id': updated_task['id'],
                'user_id': updated_task['user_id'],
                'title': updated_task['title'],
                'description': updated_task['description'],
                'status': updated_task['status'],
                'priority': updated_task['priority'],
                'due_date': updated_task['due_date'],
                'created_at': updated_task['created_at'],
                'updated_at': updated_task['updated_at'],
                'completed_at': updated_task['completed_at']
            }
        }), 200
        
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/api/tasks/<task_id>', methods=['DELETE'])
def delete_task(task_id):
    """Delete a task"""
    try:
        conn = get_db_connection()
        
        # Check if task exists
        existing_task = conn.execute('SELECT * FROM tasks WHERE id = ?', (task_id,)).fetchone()
        if not existing_task:
            conn.close()
            return jsonify({'error': 'Task not found'}), 404
        
        # Delete the task
        conn.execute('DELETE FROM tasks WHERE id = ?', (task_id,))
        conn.commit()
        conn.close()
        
        return jsonify({'message': 'Task deleted successfully'}), 200
        
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/api/tasks/stats/<user_id>', methods=['GET'])
def get_task_stats(user_id):
    """Get task statistics for a user"""
    try:
        conn = get_db_connection()
        
        # Get counts by status
        stats_query = '''
            SELECT 
                status,
                COUNT(*) as count
            FROM tasks 
            WHERE user_id = ? 
            GROUP BY status
        '''
        stats = conn.execute(stats_query, (user_id,)).fetchall()
        
        # Get overdue tasks count
        now = datetime.datetime.now().isoformat()
        overdue_count = conn.execute('''
            SELECT COUNT(*) as count
            FROM tasks 
            WHERE user_id = ? AND due_date < ? AND status != 'completed'
        ''', (user_id, now)).fetchone()['count']
        
        conn.close()
        
        # Format stats
        status_counts = {row['status']: row['count'] for row in stats}
        
        return jsonify({
            'user_id': user_id,
            'total_tasks': sum(status_counts.values()),
            'by_status': status_counts,
            'overdue_tasks': overdue_count
        }), 200
        
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

if __name__ == '__main__':
    # Initialize database on startup
    init_db()
    
    # Run the service
    port = int(os.environ.get('PORT', 5002))
    debug = os.environ.get('DEBUG', 'True').lower() == 'true'
    
    print(f"Starting Task Service on port {port}")
    print(f"User Service URL: {USER_SERVICE_URL}")
    print(f"Database path: {DATABASE}")
    print(f"Health check: http://localhost:{port}/health")
    
    app.run(host='0.0.0.0', port=port, debug=debug)